{ "nextId": 61, "blogs":[
	{
		"id": 1,
		"title": "Compiling CoffeeScript from Sublime Text 2 ",
		"content": "<p>A few days ago I configured Sublime Text 2 editor to use three different hotkeys for compiling and running CoffeeScript files. I am new to Sublime so I consider somewhat of an achievement that I was able to pull this off with help from the interwebz and a bit of luck.</p>\r\n\r\n<h3>Run a CoffeeScript file in the Sublime console</h3>\r\n<p>The first hotkey that I configured runs a CoffeeScript file and displays its output to the Sublime’s console window. This is useful when I want to quickly run a small CoffeeScript program that outputs to the console. The following screenshot shows this:</p>\r\n\r\n<p><img src=\"http://hectorcorrea.com/images/sublimetextconsole.png\"/></p>\r\n\r\n<p>To wire up this hotkey I created a new <i>Build System</i> for CoffeeScript files. You can do this via the Tools + Build System + New Build System menu option. Copy the following code inside the editor and save it as CoffeeScriptRun.sublime-build in the default directory (in my Mac the path was ~/Library/Application Support/Sublime Text 2/Packages/User)</p> \r\n\r\n<pre> \r\n{\r\n    \"cmd\": [\"coffee\", \"$file\"],\r\n    \"selector\" : \"source.coffee\",\r\n    \"path\" : \"/usr/local/bin\"\r\n}\r\n</pre>\r\n\r\n<p>From now on, when I hit <b>command+B</b> (<img src=\"http://km.support.apple.com/library/APPLE/APPLECARE_ALLGEOS/HT1343/ks_command.gif\"/> +B) while editing a CoffeeScript file, Sublime automatically calls the CoffeeScript compiler with the current opened file. Command+B is the default key in Sublime Text to run the build command. You can also run this command from the menu by going to Tools + Build. The output of the CoffeeScript will be displayed in the Sublime Text console at the bottom of the screen.</p>\r\n\r\n<h2>Generate the JavaScript file for a CoffeeScript file</h2>\r\n<p>The second command that I configured was to re-generate the JavaScript file associated with a CoffeeScript file. </p>\r\n\r\n<p>One easy way to do this is to create another build file like I did above but use a slightly different command to tell the CoffeeScript compiler to produce a JavaScript file. The disadvantage of this approach is that then I have to toggle between build modes via the Tools + Build System and then use command+B to produce the JavaScript file. This is just too many steps for something that I need to do quite often.</p>\r\n\r\n<p>What I really wanted was a hotkey to re-generate the JavaScript file in one shot. To do this I had to create a new key binding (Sublime Text wording for hotkey) by going to the Sublime Text 2 + Preferences + Key bindings - User and entering the following text:</p> \r\n\r\n<pre>\r\n[\r\n    { \"keys\": [\"super+j\"], \"command\": \"coffeescript_to_javascript\" }\r\n]\r\n</pre>\r\n\r\n<p>This tells Sublime to wire the <b>command+J</b> key to a command called “coffeescript_to_javascript”. The next step is to create the code associated with “coffeescript_to_javascript”. To do this I went to Tools + New Plugin... menu and replaced the default code with the following: </p>\r\n\r\n<pre>\r\nimport sublime, sublime_plugin\r\n\r\nclass CoffeescriptToJavascript(sublime_plugin.TextCommand):\r\n  def run(self, edit):\r\n    self.view.window().run_command('exec', {'cmd': [\"coffee\", \"-c\", self.view.file_name()]})\r\n</pre>\r\n\r\n<p>Two things to notice in this code. One is that the name of the class (CoffeescriptToJavascript) is the CamelCase version of the name of the command (“coffeescript_to_javascript”) that I defined in the key bindings. This is very important as Sublime will automatically look for a class with the CamelCase version for the value defined in the key bindings.</p> \r\n\r\n<p>I wish I could remember where I stole the idea for this code, I know it was somewhere in the <a href=\"http://www.sublimetext.com/forum/\" target=\"_blank\">Sublime message board</a> but I didn’t save the link.</p>\r\n\r\n<p>The second thing to notice is that the run command in this code is calling the CoffeeScript compiler (coffee) and passing both the -c flag to produce the JavaScript and the name of the file to compile (which will be the name of the current file being edited.) </p>\r\n\r\n<p>I saved this plugin file as CoffeeScriptCompile.py in the same location where you saved the build file that we created before. I restarted Sublime to make sure the new plugin was loaded. </p>\r\n\r\n<p>From now on, when I use <b>command+J</b> Sublime runs “coffee -c somefile.coffee” and generates the corresponding somefile.js file. This command does not output the result to the console, though. </p>\r\n\r\n<h3>Outputting the JavaScript code to the Sublime Console</h3>\r\n<p>Lastly, using the steps defined in the previous section I created another plugin to output the JavaScript to Sublime’s console rather than to a file. This is very useful when I want to dig and see how a particular CoffeeScript feature is translated to its JavaScript equivalent. </p>\r\n\r\n<p>I wired this command to the <b>command+M</b> key and pass the “-p” flag to the CoffeeScript compiler to get the JavaScript to the standard output.</p>\r\n",
		"createdOn": "2011-01-01T12:31:36.710Z",
		"updatedOn": "2012-07-17T02:28:23.700Z",
		"postedOn": "2012-07-12T02:33:00.000Z",
		"url": "compiling-coffeescript-from-sublime-text-2-"
	},
	{
		"id": 2,
		"title": "Drawing a Binary Tree in CoffeeScript",
		"content": "<p><img align=\"left\" src=\"http://hectorcorrea.com/images/binarytreecoffee.png\" alt=\"Binary Tree\" style=\"margin-right:15px\"/>\r\n\r\nA few months ago I wrote a small <b>CoffeeScript program to draw binary trees on a web page page</b> using the HTML 5 Canvas element and was very pleased with clarity and structure of the resulting code. This blog post elaborates on the code structure and how it compares to previous implementations of the same idea that I have done in other languages. </p>\r\n\r\n<p>I’ve written programs to draw binary trees before in C# and Ruby and I wasn’t sure how a CoffeeScript implementation would compare against implementations in more traditional object oriented programming languages. Thanks to CoffeeScript’s support for classes the structure of this implementation is pretty much as you would expect: a BinaryNode class to hold node data, a BinaryTree class to implement the basic binary tree operations (add, walk), and a BinaryTreeDrawer to calculate the coordinates where each of the nodes should be drawn.</p>\r\n\r\n<p>In addition, since this project requires only client-side code (I don’t store the binary tree data in a server database) it’s was very pleasant not having to deal with a context switching between a “client side” mental model and a “server side” one. This is uncommon in real life projects but it was a nice bonus for a pet project like this.</p>\r\n\r\n<p>You can see a <b>running version of this project <a href=\"http://hectorcorrea.com/binary-tree-coffee/index.html\" target=\"_blank\">here</a></b>.</p>\r\n\r\n<p>The full CoffeeScript (and JavaScript) <b>source code</b> is available on <a  href=\"https://github.com/hectorcorrea/binary-tree-coffee\" target=\"_blank\">github</a>.</p>\r\n\r\n<h3>Basic Structure of the Code</h3>\r\n<p>The main classes that I used to implement the binary tree drawer functionality are BinaryNode, a BinaryTree, and a BinaryTreeDrawer. </p>\r\n\r\n<p>The <b>BinaryNode</b> class is just a small “data class” that stores the information about each node, namely the value of the node and pointers to the node to the left and right of it. </p>\r\n\r\n<p>\r\n<script src=\"https://gist.github.com/2772787.js?file=binary_node.coffee\"></script>\r\n<noscript><a href=\"https://gist.github.com/2772787.js?file=binary_node.coffee\" target=\"_blank\">(click to view code)</a></noscript>\r\n</p>\r\n\r\n<p>The <b>BinaryTree</b> class implements the functionality to add nodes to the tree and walk the tree. The <i>add</i> method takes care of adding each new value to the tree and updating the other nodes accordingly. The <i>walk</i> method goes through each node of the tree in-order and calls another function to allow you to decide what to do on each node (e.g. print it to the screen.) </p>\r\n\r\n<p>The code for this class is shown below. Notice that this is just a partial implementation of a binary tree since it only implements the add and walk methods but is missing functionality to remove nodes, search for values, find the min and max values in the tree, et cetera. </p>\r\n\r\n<p>\r\n<script src=\"https://gist.github.com/2772787.js?file=binary_tree.coffee\"></script>\r\n<noscript><a href=\"https://gist.github.com/2772787.js?file=binary_node.coffee\" target=\"_blank\">(click to view code)</a></noscript>\r\n</p>\r\n\r\n<p>The <b>BinaryTreeDrawer</b> class walks through the nodes of the tree and calculates the coordinates where each of them should be drawn. This class does not draws the tree per-se, rather it calls a function of your choosing with the coordinates where the node should be drawn.</p>\r\n\r\n<p>\r\n<script src=\"https://gist.github.com/2772787.js?file=binary_tree_drawer.coffee\"></script>\r\n<noscript><a href=\"https://gist.github.com/2772787.js?file=binary_node.coffee\" target=\"_blank\">(click to view code)</a></noscript>\r\n</p>\r\n\r\n<h3>Console Application</h3>\r\n<p>File binary_console.coffee shows a very sample of usage of the BinaryTree and BinaryTreeDrawer classes. This console application creates a binary tree, adds a few nodes to it, and outputs to the console the coordinates where each of these nodes should be drawn. </p>\r\n\r\n<p>\r\n<script src=\"https://gist.github.com/2772787.js?file=binary_console.coffee\"></script>\r\n<noscript><a href=\"https://gist.github.com/2772787.js?file=binary_node.coffee\" target=\"_blank\">(click to view code)</a></noscript>\r\n</p>\r\n\r\n<p>If you have CoffeeScript installed on your box you can just run “coffee binary_console” and you’ll see an output similar to this:</p>\r\n\r\n<p><img src=\"http://hectorcorrea.com/images/binarytreeconsole.png\"/></p>\r\n\r\n<h3>The Demo Web Page</h3> \r\n<p>Once I implemented the BinaryTreeDrawer it was easy to hook this to a web page and actually draw a binary tree using the HTML 5 Canvas element. The callback passed to the drawer code in this case actually draws circles and lines for each node rather than just outputting the result to the console. Below is a snippet of the code found in binary_web.coffee that shows the basic code to draw the tree:</p>\r\n\r\n<p>\r\n<script src=\"https://gist.github.com/2772787.js?file=binary_web.coffee\"></script>\r\n<noscript><a href=\"https://gist.github.com/2772787.js?file=binary_node.coffee\" target=\"_blank\">(click to view code)</a></noscript>\r\n</p>\r\n\r\n<h3>Final Thoughts</h3>\r\n<p>As I said at the beginning of this blog post, I was very pleased with how succinct the code in CoffeeScript to implement a binary tree drawer ended. The clear and concise CoffeeScript syntax aided with CoffeeScript support for a traditional way of defining classes (while behind the scenes using JavaScript prototypes) resulted in code that is both easy to write, test, and maintain.  </p>\r\n\r\n<b>Related posts</b>\r\n<ul><li><a href=\"http://hectorcorrea.com/Blog/Drawing-a-Binary-Tree-in-Ruby\" target=\"_blank\">Drawing a Binary Tree in Ruby</a> (2011)</li>\r\n<li><a href=\"http://hectorcorrea.com/Blog/Binary-Tree-in-C-Sharp\" target=\"_blank\">Binary Tree in C#</a>(2006)</li></ul>",
		"createdOn": "2011-02-01T12:31:36.710Z",
		"updatedOn": "2012-07-17T02:30:36.684Z",
		"postedOn": "1969-12-31T14:00:00.000Z",
		"url": "drawing-a-binary-tree-in-coffeescript"
	},
	{
		"id": 3,
		"title": "vvv",
		"content": "This is the content of the third topic vvv",
		"createdOn": "2011-03-01T12:31:36.710Z",
		"updatedOn": "2012-06-21T02:38:04.085Z",
		"postedOn": "2012-05-01T03:20:00.000Z",
		"url": "vvv"
	},
	{
		"id": 4,
		"title": "unit test title",
		"content": "unit test content Wed Jun 20 2012 22:13:34 GMT-0400 (EDT)",
		"createdOn": "2011-04-01T12:31:36.710Z",
		"updatedOn": "2012-06-21T02:13:34.810Z",
		"postedOn": "2012-06-21T02:13:34.806Z",
		"url": "unit-test-title"
	},
	{
		"id": 57,
		"title": "vvv",
		"content": "vvvv",
		"createdOn": "2011-05-01T12:31:36.710Z",
		"updatedOn": "1970-01-01T00:00:00.000Z",
		"postedOn": "1970-01-01T00:00:00.000Z",
		"url": "vvv"
	},
	{
		"id": 58,
		"title": "new ejs",
		"content": "totally added with ejs",
		"createdOn": "2011-06-01T12:31:36.710Z",
		"updatedOn": "1970-01-01T00:00:00.000Z",
		"postedOn": "1970-01-01T00:00:00.000Z",
		"url": "new-ejs"
	},
	{
		"id": 59,
		"title": "test one two three",
		"content": "new unit test content Sun Jun 24 2012 22:49:17 GMT-0400 (EDT)",
		"createdOn": "2011-07-01T12:31:36.710Z",
		"updatedOn": "1970-01-01T00:00:00.000Z",
		"postedOn": "2012-06-25T02:49:17.508Z",
		"url": "test-one-two-three"
	},
	{
		"id": 60,
		"title": "test one two three",
		"content": "new unit test content Wed Jul 11 2012 22:37:29 GMT-0400 (EDT)",
		"createdOn": "2012-07-12T02:37:29.135Z",
		"updatedOn": "1970-01-01T00:00:00.000Z",
		"postedOn": "2012-07-12T02:37:29.128Z",
		"url": "test-one-two-three"
	}
]}